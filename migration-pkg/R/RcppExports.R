# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Blitz mini discrete choice model
#'
#' in this example we map actually arrays from R to C++
#' Arrays are vectors with a dimension attribute
#' @example examples/example-blitz1.r
dev_blitz1 <- function(data) {
    .Call('migration_dev_blitz1', PACKAGE = 'migration', data)
}

#' Blitz mini discrete choice model 2
#'
#' in this example we map vectors to C
#' @example examples/example-blitz2.r
dev_blitz2 <- function(data) {
    .Call('migration_dev_blitz2', PACKAGE = 'migration', data)
}

#' dev7: discrete optimization, housing choice, utility function
#' 
#' @example examples/example-dev7.r
dev7 <- function(data) {
    .Call('migration_dev7', PACKAGE = 'migration', data)
}

#' dev6: discrete optimization, housing choice
#' 
#' @examples
#' nA <- 100L; nY <- 5L; nT <- 5L; nH <- 2L; nP <- 3L
#' G <- rouwenhorst(rho=0.9,n=nY,sigma=0.1)$Pmat
#' dataR <- list( dims = c(nA,nY,nP,nT),
#'                theta = 1.2,beta=0.95,
#'                myNA=-99,rent=0.05,R=1/(1+0.04),down=0.2,
#'                G = as.numeric(rouwenhorst(rho=0.9,n=nY,sigma=0.1)$Pmat))
#'                
#' grids <- list()
#' grids$p <- seq(1,10,length=nP)
#' grids$a <- seq(-(1-dataR$down)*max(grids$p),10,length=nA)
#' 
#' # renter state: V = max( rent, buy )
#' 
#' # sR means you are renter
#' sR <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sR[,cons := a + y + 0.3*it - dataR$rent - dataR$R*save]
#' sR[it==nT & a>0,cons := log(a) ]
#' sR[a<0, cons := dataR$myNA]
#' sR[save<0, cons := dataR$myNA]
#' 
#' # sB is buyer: admissible savings depends on current house price.
#' sB <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sB[,cons := a + y + 0.3*it - p - dataR$R*save]
#' sB[a<0 & it!=nT ,cons := dataR$myNA]
#' sB[save < -(1-dataR$down)*p, cons := dataR$myNA, by=list(y,p,it) ]
#' 
#' # owner state: V = max( stay , sell )
#' 
#' # sS means you are seller->renter
#' sS <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sS[,cons := a + y + 0.3*it - dataR$rent + p - dataR$R*save]
#' sS[save<0, cons := dataR$myNA]
#' 
#' # sO means you are owner
#' sO <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sO[,cons := a + y + 0.3*it - dataR$R*save]
#' sO[it==nT & a+y+p>0,cons := log(a+y+p)]
#' sO[it==nT & a+y+p<0,cons := dataR$myNA]
#' 
#' # tensors
#' CR <- sR[,array(cons,c(dataR$dims,nA))]
#' CB <- sB[,array(cons,c(dataR$dims,nA))]
#' CS <- sS[,array(cons,c(dataR$dims,nA))]
#' CO <- sO[,array(cons,c(dataR$dims,nA))]
#' 
#' xR = array(0,c(dataR$dims,nA))
#' xB = array(0,c(dataR$dims,nA))
#' xS = array(0,c(dataR$dims,nA))
#' xO = array(0,c(dataR$dims,nA))
#' 
#' dataR$consR <- sR[,cons]
#' dataR$consB <- sB[,cons]
#' dataR$consS <- sS[,cons]
#' dataR$consO <- sO[,cons]
#' blitz <- dev6(data=dataR)
#' 
#' ######################################################
#' # Calculating an R solution to this lifecycle
#' ######################################################
#' 
#' Rtime <- proc.time()
#' # envelopes of conditional values
#' WO = array(0,dataR$dims)
#' WR = array(0,dataR$dims)
#' # Their expected values
#' EWO = array(0,dataR$dims)
#' EWR = array(0,dataR$dims)
#' 
#' # discrete choice amoung conditional values
#' DO = array(0,dataR$dims)
#' DR = array(0,dataR$dims)
#' 
#' # conditional values
#' VR = array(3,dataR$dims)
#' VB = array(4,dataR$dims)
#' VS = array(2,dataR$dims)
#' VO = array(1,dataR$dims)
#' 
#' # conditional savings functions
#' saveR = array(0,dataR$dims)
#' saveB = array(0,dataR$dims)
#' saveS = array(0,dataR$dims)
#' saveO = array(0,dataR$dims)
#' 
#' # conditional consumption functions
#' consR = array(0,c(nA,nY,nP,nT-1))
#' consB = array(0,c(nA,nY,nP,nT-1))
#' consS = array(0,c(nA,nY,nP,nT-1))
#' consO = array(0,c(nA,nY,nP,nT-1))
#' 
#' # final period values
#' EWR[ , , ,nT] <- sR[it==nT&save==grids$a[nA],array(cons,c(nA,nY,nP))]
#' EWO[ , , ,nT] <- sO[it==nT&save==grids$a[nA],array(cons,c(nA,nY,nP))]
#' integr <- tensorFunction(R[i,m,k] ~ V[i,j,k] * G[m,j] )
#'                            
#' for (ti in (nT-1):1) {
#'     for (ia in 1:nA) {
#'			 for (ip in 1:nP){
#' 	         for(iy in 1:nY) {
#' 				 for (ja in 1:nA){
#' 					 # renter
#' 					 if (CR[ia,iy,ip,ti,ja] < 0 | !is.finite(CR[ia,iy,ip,ti,ja])){
#' 						xR[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xR[ia,iy,ip,ti,ja] =  log(CR[ia,iy,ip,ti,ja])  + dataR$beta*EWR[ja,iy,ip,ti+1]
#' 					 }
#' 					 # buyer
#' 					 if (CB[ia,iy,ip,ti,ja] < 0 | !is.finite(CB[ia,iy,ip,ti,ja])){
#' 						xB[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xB[ia,iy,ip,ti,ja] =  log(CB[ia,iy,ip,ti,ja])  + dataR$beta*EWO[ja,iy,ip,ti+1]
#' 					 }
#' 					 # seller
#' 					 if (CS[ia,iy,ip,ti,ja] < 0 | !is.finite(CS[ia,iy,ip,ti,ja])){
#' 						xS[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xS[ia,iy,ip,ti,ja] =  log(CS[ia,iy,ip,ti,ja])  + dataR$beta*EWR[ja,iy,ip,ti+1]
#' 					 }
#' 					 # owner
#' 					 if (CO[ia,iy,ip,ti,ja] < 0 | !is.finite(CO[ia,iy,ip,ti,ja])){
#' 						xO[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xO[ia,iy,ip,ti,ja] =  log(CO[ia,iy,ip,ti,ja])  + dataR$beta*EWO[ja,iy,ip,ti+1]
#' 					 }
#' 				 }
#' 
#'     			 # renter state
#' 				 # ============
#' 
#' 				 # conditional values renter state
#' 				 VR[ia,iy,ip,ti] = max(xR[ia,iy,ip,ti, ])
#' 				 VB[ia,iy,ip,ti] = max(xB[ia,iy,ip,ti, ])
#' 				 # conditional savings renter state
#' 				 saveR[ia,iy,ip,ti] = which.max(xR[ia,iy,ip,ti, ])
#' 				 saveB[ia,iy,ip,ti] = which.max(xB[ia,iy,ip,ti, ])
#' 				 # max val renter state
#' 				 WR[ia,iy,ip,ti] = max(VR[ia,iy,ip,ti],VB[ia,iy,ip,ti])
#' 				 DR[ia,iy,ip,ti] = which.max(c(VR[ia,iy,ip,ti],VB[ia,iy,ip,ti]))
#' 
#'     			 # owner state
#' 				 # ============
#' 
#' 				 # conditional values owner state
#' 				 VS[ia,iy,ip,ti] = max(xS[ia,iy,ip,ti, ])
#' 				 VO[ia,iy,ip,ti] = max(xO[ia,iy,ip,ti, ])
#' 				 # conditional savings owner state
#' 				 saveO[ia,iy,ip,ti] = which.max(xO[ia,iy,ip,ti, ])
#' 				 saveS[ia,iy,ip,ti] = which.max(xS[ia,iy,ip,ti, ])
#' 				 # max val owner state
#' 				 WO[ia,iy,ip,ti] = max(VO[ia,iy,ip,ti],VS[ia,iy,ip,ti])
#' 				 DO[ia,iy,ip,ti] = which.max(c(VO[ia,iy,ip,ti],VS[ia,iy,ip,ti]))
#'					
#'		 			}	
#' 			}
#'         }
#' 	# integrate
#' 	# =========
#' 	
#'		 tmpO = WO[ , , ,ti]
#'		 tmpR = WR[ , , ,ti]
#'		 EWO[ , , ,ti] = integr(tmpO, G)
#'		 EWR[ , , ,ti] = integr(tmpR, G)
#'      }
#' Rtime <- proc.time() - Rtime
#' 
#' # timings
#' print(Rtime)
#' print(sum(blitz$time/1e9))
#' print(diff(blitz$time/1e9))
#'
#' # get conditional consumption functions
#' # =====================================
#' consR <- array(matrix(CR[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveR[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' consB <- array(matrix(CB[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveB[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' consS <- array(matrix(CS[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveS[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' consO <- array(matrix(CO[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveO[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' # =====================================
#' print(all.equal(WO,blitz$WO))
#' print(all.equal(WR,blitz$WR))
#' print(all.equal(EWO,blitz$EVown))
#' print(all.equal(EWR,blitz$EVrent))
#' print(all.equal(DO,blitz$DO))
#' print(all.equal(DR,blitz$DR))
#'
#' print(all.equal(VO,blitz$vstay))
#' print(all.equal(VR,blitz$vrent))
#' print(all.equal(VS,blitz$vsell))
#' print(all.equal(VB,blitz$vbuy))
#'
#' print(all.equal(saveO,blitz$saveO))
#' print(all.equal(saveR,blitz$saveR))
#' print(all.equal(saveS,blitz$saveS))
#' print(all.equal(saveB,blitz$saveB))
dev6 <- function(data) {
    .Call('migration_dev6', PACKAGE = 'migration', data)
}

#' dev5: discrete optimization, housing choice
#' 
#' @examples
#' nA <- 100L; nY <- 5L; nT <- 5L; nH <- 2L; nP <- 3L
#' 
#' dataR <- list( dims = c(nA,nY,nP,nT),
#'                theta = 1.2,beta=0.95,myNA=-99,rent=0.05,R=1/(1+0.04),down=0.2)
#'                
#' grids <- list()
#' grids$p <- seq(1,10,length=nP)
#' grids$a <- seq(-(1-dataR$down)*max(grids$p),10,length=nA)
#' 
#' # renter state: V = max( rent, buy )
#' 
#' # sR means you are renter
#' sR <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sR[,cons := a + y + 0.3*it - dataR$rent - dataR$R*save]
#' sR[it==nT & a>0,cons := log(a) ]
#' sR[a<0, cons := dataR$myNA]
#' sR[save<0, cons := dataR$myNA]
#' 
#' # sB is buyer: admissible savings depends on current house price.
#' sB <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sB[,cons := a + y + 0.3*it - p - dataR$R*save]
#' sB[a<0 & it!=nT ,cons := dataR$myNA]
#' sB[save < -(1-dataR$down)*p, cons := dataR$myNA, by=list(y,p,it) ]
#' 
#' # owner state: V = max( stay , sell )
#' 
#' # sS means you are seller->renter
#' sS <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sS[,cons := a + y + 0.3*it - dataR$rent + p - dataR$R*save]
#' sS[save<0, cons := dataR$myNA]
#' 
#' # sO means you are owner
#' sO <- data.table(expand.grid(a=grids$a,y=1:nY,p=grids$p,it=1:nT,save=grids$a))
#' sO[,cons := a + y + 0.3*it - dataR$R*save]
#' sO[it==nT & a+y+p>0,cons := log(a+y+p)]
#' sO[it==nT & a+y+p<0,cons := dataR$myNA]
#' 
#' # tensors
#' CR <- sR[,array(cons,c(dataR$dims,nA))]
#' CB <- sB[,array(cons,c(dataR$dims,nA))]
#' CS <- sS[,array(cons,c(dataR$dims,nA))]
#' CO <- sO[,array(cons,c(dataR$dims,nA))]
#' 
#' xR = array(0,c(dataR$dims,nA))
#' xB = array(0,c(dataR$dims,nA))
#' xS = array(0,c(dataR$dims,nA))
#' xO = array(0,c(dataR$dims,nA))
#' 
#' dataR$consR <- sR[,cons]
#' dataR$consB <- sB[,cons]
#' dataR$consS <- sS[,cons]
#' dataR$consO <- sO[,cons]
#' blitz <- dev5(data=dataR)
#' 
#' ######################################################
#' # Calculating an R solution to this lifecycle
#' ######################################################
#' 
#' Rtime <- proc.time()
#' # envelopes of conditional values
#' WO = array(0,dataR$dims)
#' WR = array(0,dataR$dims)
#' 
#' # discrete choice amoung conditional values
#' DO = array(0,dataR$dims)
#' DR = array(0,dataR$dims)
#' 
#' # conditional values
#' VR = array(0,dataR$dims)
#' VB = array(0,dataR$dims)
#' VS = array(0,dataR$dims)
#' VO = array(0,dataR$dims)
#' 
#' # conditional savings functions
#' saveR = array(0,dataR$dims)
#' saveB = array(0,dataR$dims)
#' saveS = array(0,dataR$dims)
#' saveO = array(0,dataR$dims)
#' 
#' # conditional consumption functions
#' consR = array(0,c(nA,nY,nP,nT-1))
#' consB = array(0,c(nA,nY,nP,nT-1))
#' consS = array(0,c(nA,nY,nP,nT-1))
#' consO = array(0,c(nA,nY,nP,nT-1))
#' 
#' # final period values
#' WR[ , , ,nT] <- sR[it==nT&save==grids$a[nA],array(cons,c(nA,nY,nP))]
#' WO[ , , ,nT] <- sO[it==nT&save==grids$a[nA],array(cons,c(nA,nY,nP))]
#' # WR[ , , ,nT] <- sT[,array(log(cashR),c(nA,nY,nP))]
#' # WO[ , , ,nT] <- sT[,array(log(cashO),c(nA,nY,nP))]
#' # WR[is.nan(WR)] <- dataR$myNA
#' # WO[is.nan(WR)] <- dataR$myNA
#' 
#' for (ti in (nT-1):1) {
#'     for (ia in 1:nA) {
#'          for(iy in 1:nY) {
#' 			 for (ip in 1:nP){
#' 				 for (ja in 1:nA){
#' 					 # renter
#' 					 if (CR[ia,iy,ip,ti,ja] < 0 | !is.finite(CR[ia,iy,ip,ti,ja])){
#' 						xR[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xR[ia,iy,ip,ti,ja] =  log(CR[ia,iy,ip,ti,ja])  + dataR$beta*WR[ja,iy,ip,ti+1]
#' 					 }
#' 					 # buyer
#' 					 if (CB[ia,iy,ip,ti,ja] < 0 | !is.finite(CB[ia,iy,ip,ti,ja])){
#' 						xB[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xB[ia,iy,ip,ti,ja] =  log(CB[ia,iy,ip,ti,ja])  + dataR$beta*WO[ja,iy,ip,ti+1]
#' 					 }
#' 					 # seller
#' 					 if (CS[ia,iy,ip,ti,ja] < 0 | !is.finite(CS[ia,iy,ip,ti,ja])){
#' 						xS[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xS[ia,iy,ip,ti,ja] =  log(CS[ia,iy,ip,ti,ja])  + dataR$beta*WR[ja,iy,ip,ti+1]
#' 					 }
#' 					 # owner
#' 					 if (CO[ia,iy,ip,ti,ja] < 0 | !is.finite(CO[ia,iy,ip,ti,ja])){
#' 						xO[ia,iy,ip,ti,ja] = dataR$myNA
#' 					 } else {
#' 						xO[ia,iy,ip,ti,ja] =  log(CO[ia,iy,ip,ti,ja])  + dataR$beta*WO[ja,iy,ip,ti+1]
#' 					 }
#' 				 }
#' 
#'     			 # renter state
#' 				 # ============
#' 
#' 				 # conditional values renter state
#' 				 VR[ia,iy,ip,ti] = max(xR[ia,iy,ip,ti, ])
#' 				 VB[ia,iy,ip,ti] = max(xB[ia,iy,ip,ti, ])
#' 				 # conditional savings renter state
#' 				 saveR[ia,iy,ip,ti] = which.max(xR[ia,iy,ip,ti, ])
#' 				 saveB[ia,iy,ip,ti] = which.max(xB[ia,iy,ip,ti, ])
#' 				 # max val renter state
#' 				 WR[ia,iy,ip,ti] = max(VR[ia,iy,ip,ti],VB[ia,iy,ip,ti])
#' 				 DR[ia,iy,ip,ti] = which.max(c(VR[ia,iy,ip,ti],VB[ia,iy,ip,ti]))
#' 
#'     			 # owner state
#' 				 # ============
#' 
#' 				 # conditional values owner state
#' 				 VS[ia,iy,ip,ti] = max(xS[ia,iy,ip,ti, ])
#' 				 VO[ia,iy,ip,ti] = max(xO[ia,iy,ip,ti, ])
#' 				 # conditional savings owner state
#' 				 saveO[ia,iy,ip,ti] = which.max(xO[ia,iy,ip,ti, ])
#' 				 saveS[ia,iy,ip,ti] = which.max(xS[ia,iy,ip,ti, ])
#' 				 # max val owner state
#' 				 WO[ia,iy,ip,ti] = max(VO[ia,iy,ip,ti],VS[ia,iy,ip,ti])
#' 				 DO[ia,iy,ip,ti] = which.max(c(VO[ia,iy,ip,ti],VS[ia,iy,ip,ti]))
#' 
#' 			 }
#'          }
#'      }
#' }
#' Rtime <- proc.time() - Rtime
#' 
#' # timings
#' print(Rtime)
#' print(sum(blitz$time/1e9))
#' print(diff(blitz$time/1e9))
#'
#' # get conditional consumption functions
#' # =====================================
#' consR <- array(matrix(CR[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveR[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' consB <- array(matrix(CB[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveB[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' consS <- array(matrix(CS[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveS[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' consO <- array(matrix(CO[ , , ,1:(nT-1), ],nA*nY*nP*(nT-1),nA)[cbind(1:(nA*nY*nP*(nT-1)),as.numeric(saveO[ , , ,1:(nT-1)]))], c(nA,nY,nP,nT-1))
#' # =====================================
#' print(all.equal(WO,blitz$WO))
#' print(all.equal(WR,blitz$WR))
#' print(all.equal(DO,blitz$DO))
#' print(all.equal(DR,blitz$DR))
#'
#' print(all.equal(VO,blitz$VO))
#' print(all.equal(VR,blitz$VR))
#' print(all.equal(VS,blitz$VS))
#' print(all.equal(VB,blitz$VB))
#'
#' print(all.equal(saveO,blitz$saveO))
#' print(all.equal(saveR,blitz$saveR))
#' print(all.equal(saveS,blitz$saveS))
#' print(all.equal(saveB,blitz$saveB))
dev5 <- function(data) {
    .Call('migration_dev5', PACKAGE = 'migration', data)
}

#' dev4
#'
#' @examples
#' nA <- 20L; nY <- 3L; nT <- 3L
#' s <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s[,cash1 := a + y + 0.3*it]
#' s[,cash2 := a + y + 0.2*it + 0.09*it^2]
#' save <- seq(0,10,length=nA)
#' ss <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT,save=save))
#' ss[,cons1 := a + y + 0.3*it - save]
#' ss[,cons2 := a + y + 0.2*it + 0.09*it^2 - save]
#' dataR <- list( cash1 = s[["cash1"]],
#'                cash2 = s[["cash2"]],
#'                dims = c(nA,nY,nT),
#'                savings = save,
#'                theta = 1.2,beta=0.95,myNA=-99)
#' blitz <- dev4(data=dataR)
#' 
#' ######################################################
#' # Calculating an R solution to this 3-period lifecycle
#' # with discrete choice in periods 1 and 2.
#' ######################################################
#' 
#'	V = array(0,c(nA,nY,nT))  # max( v1, v2 )
#'	D = array(0,c(nA,nY,nT))  # which.max( v1, v2 )
#'	v1 = array(0,c(nA,nY,nT))
#'	v2 = array(0,c(nA,nY,nT))
#'	S1 = array(0,c(nA,nY,nT))
#'	S2 = array(0,c(nA,nY,nT))
#'	V[ , ,3] = s[it==3,log(cash1)]
#' C1 = ss[,array(cons1,c(nA,nY,nT,nA))]
#' C2 = ss[,array(cons2,c(nA,nY,nT,nA))]
#' 
#' W1 = array(0,c(nA,nY,nT,nA))
#' W2 = array(0,c(nA,nY,nT,nA))
#' for (ti in 2:1) {
#'     for (ia in 1:nA) {
#'          for(iy in 1:nY) {
#'              for (ja in 1:nA){
#' 				 # optimal cons option 1
#'                  if (C1[ia,iy,ti,ja] > 0){
#' 		     		W1[ia,iy,ti,ja] = log(C1[ia,iy,ti,ja]) + dataR$beta*V[ja,iy,ti+1]
#' 			     } else {
#' 			        W1[ia,iy,ti,ja] = dataR$myNA
#' 			     }
#' 				 # optimal cons option 2
#'                  if (C2[ia,iy,ti,ja] > 0){
#' 		     		W2[ia,iy,ti,ja] = log(C2[ia,iy,ti,ja]) + dataR$beta*V[ja,iy,ti+1]
#' 			     } else {
#' 			        W2[ia,iy,ti,ja] = dataR$myNA
#' 			     }
#' 		     }
#' 			v1[ia,iy,ti] = max(W1[ia,iy,ti, ])
#' 			S1[ia,iy,ti] = which.max(W1[ia,iy,ti, ])
#' 			v2[ia,iy,ti] = max(W2[ia,iy,ti, ])
#' 			S2[ia,iy,ti] = which.max(W2[ia,iy,ti, ])
#'				V[ia,iy,ti] = max(v1[ia,iy,ti], v2[ia,iy,ti])
#'				D[ia,iy,ti] = which.max(c(v1[ia,iy,ti], v2[ia,iy,ti]))
#'	         }
#'	     }
#'	}
#' Cstar1 = array(matrix(C1[ , ,1:(nT-1), ],nA*nY*(nT-1),nA)[cbind(1:(nA*nY*(nT-1)),as.numeric(S1[ , ,1:(nT-1)]))], c(nA,nY,nT-1))
#' Cstar2 = array(matrix(C2[ , ,1:(nT-1), ],nA*nY*(nT-1),nA)[cbind(1:(nA*nY*(nT-1)),as.numeric(S2[ , ,1:(nT-1)]))], c(nA,nY,nT-1))
#' CstarBlitz1 = array( matrix(C1[ , ,1:(nT-1), ],nA*nY*(nT-1),nA)[cbind(1:(nA*nY*(nT-1)),as.numeric(blitz$save1[ , ,1:(nT-1)]) ) ], c(nA,nY,nT-1))
#' CstarBlitz2 = array( matrix(C2[ , ,1:(nT-1), ],nA*nY*(nT-1),nA)[cbind(1:(nA*nY*(nT-1)),as.numeric(blitz$save2[ , ,1:(nT-1)]) ) ], c(nA,nY,nT-1))
#' 
#' ############################################
#' # comparing R and blitz++ solutions
#' ############################################
#' 
#' print(all.equal(V,blitz$V))
#' print(all.equal(C1,blitz$cons1))
#' print(all.equal(C2,blitz$cons2))
#' print(all.equal(v1,blitz$v1))
#' print(all.equal(v2,blitz$v2))
#' print(all.equal(S1,blitz$save1))
#' print(all.equal(S2,blitz$save2))
#' print(all.equal(Cstar1,CstarBlitz1))
#' print(all.equal(Cstar2,CstarBlitz2))
dev4 <- function(data) {
    .Call('migration_dev4', PACKAGE = 'migration', data)
}

#' dev3H
#'
#' @examples
#' nA <- 5L; nY <- 3L; nT <- 3L
#' s1 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s1[,cash := a + y + 0.3*it]
#' save <- seq(0,10,length=nA)
#' s3 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT,save=save))
#' s3[,cons := a + y + 0.3*it - save]
#' dataR <- list( cash1 = s1[["cash"]],
#'                dims = c(nA,nY,nT),
#'                savings = save,
#'                theta = 1.2,beta=0.95,myNA=-99)
#' blitz <- dev3H(data=dataR)
#' 
#' ######################################################
#' # Calculating an R solution to this 3-period lifecycle
#' ######################################################
#' 
#' V = array(0,c(nA,nY,nT))
#' V[ , ,3] = s1[it==3,log(cash)]
#' C = s3[,array(cons,c(nA,nY,nT,nA))]
#' W = array(0,c(nA,nY,nT,nA))
#' for (ti in 2:1) {
#'     for (ia in 1:nA) {
#'          for(iy in 1:nY) {
#'              for (ja in 1:nA){
#'                  if (C[ia,iy,ti,ja] > 0){
#' 		     		W[ia,iy,ti,ja] =  log(C[ia,iy,ti,ja])  + dataR$beta*V[ja,iy,ti+1]
#' 			     } else {
#' 			        W[ia,iy,ti,ja] = dataR$myNA
#' 			     }
#' 		     }
#' 			V[ia,iy,ti] = max(W[ia,iy,ti, ])
#'          }
#'      }
#'	}
#' ############################################
#' # comparing R and blitz++ solutions
#' ############################################
#' 
#' print(all.equal(V,blitz$V1))
#' print(all.equal(W[ , ,1, ],blitz$w))
#' print(all.equal(C,blitz$cons))
dev3H <- function(data) {
    .Call('migration_dev3H', PACKAGE = 'migration', data)
}

#' dev3
#'
#' @examples
#' nA <- 5L; nY <- 3L; nT <- 3L
#' s1 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s1[,cash := a + y + 0.3*it]
#' save <- seq(0,10,length=nA)
#' s3 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT,save=save))
#' s3[,cons := a + y + 0.3*it - save]
#' dataR <- list( cash1 = s1[["cash"]],
#'                dims = c(nA,nY,nT),
#'                savings = save,
#'                theta = 1.2,beta=0.95,myNA=-99)
#' blitz <- dev3(data=dataR)
#' 
#' ######################################################
#' # Calculating an R solution to this 3-period lifecycle
#' ######################################################
#' 
#' V = array(0,c(nA,nY,nT))
#' V[ , ,3] = s1[it==3,log(cash)]
#' C = s3[,array(cons,c(nA,nY,nT,nA))]
#' W = array(0,c(nA,nY,nT,nA))
#' for (ti in 2:1) {
#'     for (ia in 1:nA) {
#'          for(iy in 1:nY) {
#'              for (ja in 1:nA){
#'                  if (C[ia,iy,ti,ja] > 0){
#' 		     		W[ia,iy,ti,ja] =  log(C[ia,iy,ti,ja])  + dataR$beta*V[ja,iy,ti+1]
#' 			     } else {
#' 			        W[ia,iy,ti,ja] = dataR$myNA
#' 			     }
#' 		     }
#' 			V[ia,iy,ti] = max(W[ia,iy,ti, ])
#'          }
#'      }
#'	}
#' ############################################
#' # comparing R and blitz++ solutions
#' ############################################
#' 
#' print(all.equal(V,blitz$V1))
#' print(all.equal(W[ , ,1, ],blitz$w))
#' print(all.equal(C,blitz$cons))
dev3 <- function(data) {
    .Call('migration_dev3', PACKAGE = 'migration', data)
}

#' dev2
#'
#' @examples
#' nA <- 5L; nY <- 3L; nT <- 3L
#' s1 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s1[,cash := a + y + 0.3*it]
#' s2 <- copy(s1)
#' s2[,cash := a + y + 0.2*it + 0.09*it^2]
#' save <- seq(0,10,length=nA)
#' dataR <- list( cash1 = s1[["cash"]],
#'                cash2 = s2[["cash"]],
#'                dims = c(nA,nY,nT),
#'                savings = save,
#'                theta = 1.2,beta=0.95,myNA=-99)
#' blitz <- dev2(data=dataR)
#' V1_R = s1[,array(cash,c(nA,nY,nT))]
#' V1_R[ , ,3] = log(V1_R[ , ,3])
#' for (ti in 2:1) {
#'     for (ia in 1:nA) {
#'          for(iy in 1:nY) {
#'				if (V1_R[ia,iy,ti]<0) {
#'					V1_R[ia,iy,ti] <- dataR$myNA
#'				} else {
#'					V1_R[ia,iy,ti] = log(V1_R[ia,iy,ti]) + dataR$beta*V1_R[ia,iy,ti+1]
#'				}
#'          }
#'      }
#' }
#' print(all.equal(V1_R,blitz$V1))
dev2 <- function(data) {
    .Call('migration_dev2', PACKAGE = 'migration', data)
}

#' dev2a
#'
#' @examples
#' nA <- 5L; nY <- 3L; nT <- 3L
#' s1 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s1[,cash := a + y + 0.3*it]
#' s2 <- copy(s1)
#' s2[,cash := a + y + 0.2*it + 0.09*it^2]
#' save <- seq(0,10,length=nA)
#' dataR <- list( cash1 = s1[["cash"]],
#'                cash2 = s2[["cash"]],
#'                dims = c(nA,nY,nT),
#'                savings = save,
#'                theta = 1.2,beta=0.95,myNA=-99)
#' blitz <- dev2a(data=dataR)
#' V1_R = s1[,array(cash,c(nA,nY,nT))]
#' V1_R[ , ,3] = log(V1_R[ , ,3])
#' for (ti in 2:1) {
#'     for (ia in 1:nA) {
#'          for(iy in 1:nY) {
#'				if (V1_R[ia,iy,ti]<0) {
#'					V1_R[ia,iy,ti] <- dataR$myNA
#'				} else {
#'					V1_R[ia,iy,ti] = log(V1_R[ia,iy,ti]) + dataR$beta*V1_R[ia,iy,ti+1]
#'				}
#'          }
#'      }
#' }
#' print(all.equal(V1_R,blitz$V1))
dev2a <- function(data) {
    .Call('migration_dev2a', PACKAGE = 'migration', data)
}

#' dev1
#'
#' @examples
#' nA <- 5L; nY <- 3L; nT <- 3L
#' s1 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s1[,cash := a + y + 0.3*it]
#' s2 <- copy(s1)
#' s2[,cash := a + y + 0.2*it + 0.09*it^2]
#' save <- seq(0,10,length=nA)
#' dataR <- list( cash1 = s1[["cash"]],
#'                cash2 = s2[["cash"]],
#'                dims = c(nA,nY,nT),
#'                savings = save,
#'                theta = 1.2)
#' blitz <- dev1(data=dataR)
#' print(all.equal(s1[it==3,array(log(cash),c(nA,nY))],blitz$V1[ , ,3]))
dev1 <- function(data) {
    .Call('migration_dev1', PACKAGE = 'migration', data)
}

#' devC
#'
#' @examples
#' nA <- 5L; nY <- 3L; nT <- 3L
#' s1 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT))
#' s1[,cash := a + y + 0.3*it]
#' s2 <- copy(s1)
#' s2[,cash := a + y + 0.2*it + 0.09*it^2]
#' save <- seq(0,10,length=nA)
#' dataR <- list( cash1 = s1[["cash"]],
#'                cash2 = s2[["cash"]],
#'                dims = c(nA,nY,nT),
#'                savings = save)
#' blitz <- devC(data=dataR)
#' s3 <- data.table(expand.grid(a=seq(0,10,length=nA),y=1:nY,it=1:nT,save=save))
#' s3[,cons := a + y + 0.3*it - save]
#' print(all.equal(s3[,array(cons,c(nA,nY,nT,nA))],blitz$vmax))
devC <- function(data) {
    .Call('migration_devC', PACKAGE = 'migration', data)
}

